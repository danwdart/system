# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

let
  netboot = import (pkgs.path + "/nixos/lib/eval-config.nix") {
    modules = [
      (pkgs.path + "/nixos/modules/installer/netboot/netboot-minimal.nix")
      {
        # you will want to add options here to support your filesystem
        # and also maybe ssh to let you in
        # boot.supportedFilesystems = [ "zfs" ];
        boot.kernelModules = [ "kvm-intel" ];
        system.stateVersion = "24.11";
      }
    ];
  };
in {
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "uas" "usb_storage" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" ];
  boot.extraModulePackages = [ ];
  
  boot.loader.systemd-boot.enable = true;
  boot.loader.systemd-boot.xbootldrMountPoint = "/boot";
  # boot.loader.systemd-boot.extraEntries = {
  #   "nixos-installer.conf" = ''
  #     title NixOS Installer
  #     version 24.11
  #     linux ($drive1)/rescue-kernel init=${netboot.config.system.build.toplevel}/init ${toString netboot.config.boot.kernelParams}
  #     initrd ($drive1)/rescue-initrd
  #     options i915.enable_gvt=1
  #   '';
  # };
  # boot.loader.systemd-boot.extraFiles = {
  #   "rescue-kernel" = "${netboot.config.system.build.kernel}/bzImage";
  #   "rescue-initrd" = "${netboot.config.system.build.netbootRamdisk}/initrd";
  # };
  boot.loader.efi.canTouchEfiVariables = true;
  boot.loader.efi.efiSysMountPoint = "/efi";

  # fileSystems."/" = lib.mkDefault
  #   { device = "/dev/disk/by-uuid/1778de2b-8859-4988-9fed-cbd53b8fb7cf";
  #     fsType = "ext4";
  #     options = [ "noatime" ];
  #   };

  fileSystems."/" = {
    device = "tmpfs";
    fsType = "tmpfs";
    options = [
      "size=16G"
    ];
  };

  fileSystems."/persist" =
  { device = "/dev/disk/by-uuid/1778de2b-8859-4988-9fed-cbd53b8fb7cf";
    fsType = "ext4";
    neededForBoot = true;
    options = [ "noatime" ];
  };

  fileSystems."/efi" =
    { device = "/dev/disk/by-uuid/18A6-ECFF";
      fsType = "vfat";
      options = [ "fmask=0022" "dmask=0022" ];
    };

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/9C62-E073";
      fsType = "vfat";
      options = [ "fmask=0022" "dmask=0022" ];
    };

  swapDevices = [ ];
  
  zramSwap = {
    enable = true;
    algorithm = "zstd";
    # numDevices = 1; # Using ZRAM devices as general purpose ephemeral block devices is no longer supported
    swapDevices = 1;
    memoryPercent = 50;
  };

  environment.persistence."/persist" = {
    hideMounts = true;
    directories = [
      "/etc/ssh"
      "/etc/NetworkManager"
      "/etc/secureboot"
      "/var/lib"
      "/root/.cache/nix" # for when rebuilding the system
      "/nix"
    ];
    files = [
      "/etc/machine-id"
      # "/root/.nix-channels" # keeps dying
    ];
    users.dwd = { # todo imports = [ /path/to/impermanence/home-manager.nix ]; & move to home.persistence."/persist/home/dwd" on flag
      directories = [
        "code"
        "Desktop"
        "Documents"
        "Downloads"
        "from"
        "games"
        "Music"
        "Pictures"
        "qsstv"
        "radioimages"
        "Templates" # Really? I don't even use that. But should I? There's no harm...
        "Videos"
        "VMs"
        ".android"
        ".armagetronad"
        ".azure" # for work, TODO split out?
        ".cache/nix" # Stop having to keep redownloading tarballs and search indices
        ".cache/spotify" # Keep me logged in
        ".config/autostart"
        ".config/cachix"
        ".config/calibre"
        ".config/Code/Backups" # Unsaved open files and workspaces
        ".config/discord"
        ".config/doctl"
        ".config/dolphin-emu"
        ".config/Element"
        ".config/gh"
        ".config/Gpredict"
        ".config/htop"
        ".config/Insomnia"
        ".config/kdeconnect"
        ".config/Microsoft/Microsoft Teams"
        ".config/nethack"
        ".config/Nextcloud"
        ".config/ON4QZ" # qsstv
        ".config/PCSX2"
        # ".config/Postman"
        ".config/rclone"
        ".config/spotify" # cache as well?
        ".config/Slack"
        # ".config/VirtualBox" # TODO move?
        ".dosbox"
        ".fldigi"
        ".flrig"
        ".frozen-bubble"
        ".ghc"
        { directory = ".gnupg"; mode = "0700"; }
        ".googleearth"
        # ".kde"
        ".lgames"
        ".local/share/Baba_Is_You"
        ".local/share/citra-emu"
        ".local/share/direnv"
        ".local/share/dolphin-emu"
        ".local/share/ktorrent"
        ".local/share/kwalletd"
        ".local/share/networkmanagement"
        ".local/share/Steam"
        ".local/share/WSJT-X"
        ".mozilla"
        # ".ngrok2"
        ".pcsxr"
        ".quakespasm"
        ".serverless"
        { directory = ".ssh"; mode = "0700"; }
        ".steam" # TODO copy/link, don't mount
        ".thunderbird"
        ".tor project"
        # ".vagrant.d" # TODO relocate
        ".vkquake"
        ".wine"
        # ".yq2"
      ];
      files = [
        ".bash_history"
        ".config/Code/storage.json" # Open files and workspaces
        ".config/Code/User/globalStorage/state.vscdb" # Current state
        ".config/dolphinrc"
        ".config/kdeglobals"
        ".config/ktorrentrc"
        ".config/mimeapps.list"
        ".config/plasma-org.kde.plasma.desktop-appletsrc"
        ".config/plasmarc"
        ".config/plasmashellrc"
        ".config/powerdevilrc"
        ".config/powermanagementprofilesrc"
        ".config/WSJT-X.ini"
        ".local/share/user-places.xbel"
        ".nix-channels"
        ".serverlessrc"
      ];
    };
  };

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.docker0.useDHCP = lib.mkDefault true;
  # networking.interfaces.wlp1s0.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
